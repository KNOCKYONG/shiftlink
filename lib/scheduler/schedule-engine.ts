import { createClient } from '@/lib/supabase/server'
import { 
  WorkPatternPreference, 
  calculatePatternScore,
  recommendWorkPattern,
  WORK_PATTERN_TEMPLATES 
} from './work-pattern-types'
import { NursingPatternAnalyzer } from './nursing-pattern-analyzer'

export interface Employee {
  id: string
  name: string
  role: 'admin' | 'manager' | 'employee'
  tenant_id: string
  team_id?: string
  level: number
  is_active: boolean
  employee_code: string
  preferences?: EmployeePreference[]
  constraints?: EmployeeConstraint[]
}

export interface EmployeePreference {
  id: string
  employee_id: string
  preference_pattern: string[] // ['night', 'day', 'evening', 'off']
  priority: number
  effective_from: string
  effective_to?: string
}

export interface EmployeeConstraint {
  id: string
  employee_id: string
  constraint_type: 'no_night' | 'fixed_day' | 'time_off' | 'max_consecutive'
  constraint_value: any
  reason?: string
  effective_from: string
  effective_to?: string
}

export interface ShiftTemplate {
  id: string
  name: string
  type: 'day' | 'evening' | 'night' | 'off'
  start_time: string
  end_time: string
  required_count: number
  tenant_id: string
}

export interface ScheduleRule {
  id: string
  tenant_id: string
  rule_name: string
  rule_type: 'min_rest_hours' | 'max_weekly_hours' | 'max_consecutive_nights' | 'min_staff_per_shift'
  rule_value: number
  is_active: boolean
}

export interface GeneratedAssignment {
  employee_id: string
  shift_template_id: string
  date: string
  start_time: string
  end_time: string
  is_overtime: boolean
  confidence_score: number
}

export interface MentorshipRelationship {
  id: string
  mentor_id: string
  mentee_id: string
  tenant_id: string
  start_date: string
  end_date?: string
  status: 'active' | 'completed' | 'paused' | 'cancelled'
  mentorship_type: 'onboarding' | 'skill_development' | 'leadership' | 'general'
  pairing_strength: number // 1-10
  notes?: string
}

export interface MentoringRequirements {
  id: string
  tenant_id: string
  min_level_difference: number
  same_shift_required: boolean
  max_mentees_per_mentor: number
  pairing_duration_days: number
  min_overlap_hours: number
  auto_pairing_enabled: boolean
}

export class ScheduleEngine {
  private supabase: any
  private tenantId: string
  private nursingAnalyzer: NursingPatternAnalyzer
  private cachedMentorships: MentorshipRelationship[] = []
  private cachedMentoringRequirements: MentoringRequirements | null = null
  private cachedEmployeePreferences: Map<string, any[]> = new Map()
  private cachedFairnessLedger: Map<string, any> = new Map()

  constructor(tenantId: string) {
    this.tenantId = tenantId
    this.supabase = createClient()
    this.nursingAnalyzer = new NursingPatternAnalyzer()
  }

  /**
   * Main schedule generation method
   */
  async generateSchedule(
    startDate: string,
    endDate: string,
    employees: Employee[],
    shiftTemplates: ShiftTemplate[],
    rules: ScheduleRule[]
  ): Promise<GeneratedAssignment[]> {
    console.log(`Generating schedule from ${startDate} to ${endDate}`)

    const assignments: GeneratedAssignment[] = []
    const currentDate = new Date(startDate)
    const finalDate = new Date(endDate)

    // Get employee preferences, constraints, work patterns, mentorships, and default requests
    const employeePrefs = await this.getEmployeePreferences(employees.map(e => e.id))
    const employeeConstraints = await this.getEmployeeConstraints(employees.map(e => e.id))
    const workPatterns = await this.getWorkPatternPreferences(employees.map(e => e.id))
    const currentMonth = new Date(startDate).toISOString().slice(0, 7) + '-01'
    const fairnessLedger = await this.getFairnessLedger(employees.map(e => e.id), currentMonth)
    const mentorships = await this.getActiveMentorships(this.tenantId, startDate, endDate)
    const mentoringRequirements = await this.getMentoringRequirements(this.tenantId)
    const defaultRequests = await this.getActiveDefaultRequests(this.tenantId, startDate, endDate)

    while (currentDate <= finalDate) {
      const dateStr = currentDate.toISOString().split('T')[0]
      
      // Generate assignments for this date
      const dailyAssignments = await this.generateDailySchedule(
        dateStr,
        employees,
        shiftTemplates,
        rules,
        employeePrefs,
        employeeConstraints,
        workPatterns,
        mentorships,
        mentoringRequirements,
        defaultRequests,
        assignments // Previous assignments for context
      )

      assignments.push(...dailyAssignments)
      currentDate.setDate(currentDate.getDate() + 1)
    }

    // Optimize schedule for fairness and preferences
    const optimizedAssignments = this.optimizeSchedule(assignments, employees, rules)

    return optimizedAssignments
  }

  /**
   * Generate schedule for a single day
   */
  private async generateDailySchedule(
    date: string,
    employees: Employee[],
    shiftTemplates: ShiftTemplate[],
    rules: ScheduleRule[],
    preferences: Map<string, EmployeePreference[]>,
    constraints: Map<string, EmployeeConstraint[]>,
    workPatterns: Map<string, WorkPatternPreference>,
    mentorships: MentorshipRelationship[],
    mentoringRequirements: MentoringRequirements | null,
    defaultRequests: any[],
    previousAssignments: GeneratedAssignment[]
  ): Promise<GeneratedAssignment[]> {
    const dailyAssignments: GeneratedAssignment[] = []

    // üéØ 1Îã®Í≥Ñ: ÏÇ¨Ï†Ñ ÏöîÏ≤≠ÏÇ¨Ìï≠ Ïö∞ÏÑ† Ï≤òÎ¶¨ (ÏµúÍ≥† Ïö∞ÏÑ†ÏàúÏúÑ)
    const preAssignedEmployees = await this.processDefaultRequests(
      date, 
      employees, 
      shiftTemplates, 
      defaultRequests, 
      dailyAssignments
    )
    
    console.log(`üìã ÏÇ¨Ï†Ñ ÏöîÏ≤≠ Ï≤òÎ¶¨ ÏôÑÎ£å: ${preAssignedEmployees.length}Î™Ö Î∞∞Ï†ïÎê®`)

    // Sort shifts by priority (critical coverage first)
    const sortedShifts = this.sortShiftsByPriority(shiftTemplates)

    for (const shiftTemplate of sortedShifts) {
      // Ïù¥ÎØ∏ Ìï¥Îãπ ÏãúÌîÑÌä∏Ïóê ÏÇ¨Ï†Ñ Î∞∞Ï†ïÎêú Ïù∏Ïõê ÌôïÏù∏
      const alreadyAssigned = dailyAssignments.filter(
        assignment => assignment.shift_template_id === shiftTemplate.id
      ).length
      
      const remainingRequired = Math.max(0, shiftTemplate.required_count - alreadyAssigned)
      
      if (remainingRequired === 0) {
        console.log(`‚úÖ ${shiftTemplate.name} ÏãúÌîÑÌä∏Îäî ÏÇ¨Ï†Ñ ÏöîÏ≤≠ÏúºÎ°ú Ï∂©Ï°±Îê®`)
        continue
      }

      // Get available employees for this shift (ÏÇ¨Ï†Ñ Î∞∞Ï†ïÎêú ÏßÅÏõê Ï†úÏô∏)
      const availableEmployees = this.getAvailableEmployees(
        date,
        shiftTemplate,
        employees,
        constraints,
        previousAssignments,
        dailyAssignments
      )

      // Score employees based on preferences, fairness, rules, mentorship, and nursing pattern safety
      const scoredEmployees = this.scoreEmployeesForShift(
        date,
        shiftTemplate,
        availableEmployees,
        preferences,
        workPatterns,
        previousAssignments,
        rules,
        dailyAssignments
      )

      // Ensure organization hierarchy coverage (ÎÇ®ÏùÄ Ïù∏Ïõê Í∏∞Ï§Ä)
      const selectedEmployees = await this.selectEmployeesWithHierarchy(
        scoredEmployees,
        remainingRequired,
        employees,
        request.team_id
      )

      // Create assignments
      for (const employee of selectedEmployees) {
        dailyAssignments.push({
          employee_id: employee.id,
          shift_template_id: shiftTemplate.id,
          date,
          start_time: shiftTemplate.start_time,
          end_time: shiftTemplate.end_time,
          is_overtime: this.isOvertime(employee.id, date, previousAssignments),
          confidence_score: this.calculateConfidenceScore(employee, shiftTemplate, preferences, workPatterns)
        })
      }
    }

    return dailyAssignments
  }

  /**
   * Get available employees for a shift considering constraints
   */
  private getAvailableEmployees(
    date: string,
    shiftTemplate: ShiftTemplate,
    employees: Employee[],
    constraints: Map<string, EmployeeConstraint[]>,
    previousAssignments: GeneratedAssignment[],
    dailyAssignments: GeneratedAssignment[]
  ): Employee[] {
    return employees.filter(employee => {
      // Check if already assigned today
      if (dailyAssignments.some(a => a.employee_id === employee.id)) {
        return false
      }

      // Check employee constraints
      const empConstraints = constraints.get(employee.id) || []
      for (const constraint of empConstraints) {
        if (this.violatesConstraint(constraint, shiftTemplate, date)) {
          return false
        }
      }

      // Check minimum rest hours
      if (!this.hasMinimumRestHours(employee.id, date, shiftTemplate, previousAssignments)) {
        return false
      }

      // Check maximum consecutive nights
      if (shiftTemplate.type === 'night' && 
          this.exceedsMaxConsecutiveNights(employee.id, date, previousAssignments)) {
        return false
      }

      return true
    })
  }

  /**
   * Score employees based on preferences, work patterns, mentorship, and fairness
   */
  private scoreEmployeesForShift(
    date: string,
    shiftTemplate: ShiftTemplate,
    employees: Employee[],
    preferences: Map<string, EmployeePreference[]>,
    workPatterns: Map<string, WorkPatternPreference>,
    previousAssignments: GeneratedAssignment[],
    rules: ScheduleRule[],
    dailyAssignments: GeneratedAssignment[] = []
  ): Array<{ employee: Employee; score: number }> {
    return employees.map(employee => {
      let score = 0

      // Preference matching score (0-40 points)
      const prefScore = this.calculatePreferenceScore(employee.id, shiftTemplate, preferences, date)
      score += prefScore

      // Work pattern score (0-30 points) - ÏßßÏùÄ/Í∏¥ Í∑ºÎ¨¥ Ìå®ÌÑ¥ ÏÑ†Ìò∏ÎèÑ Î∞òÏòÅ
      const patternScore = this.calculateWorkPatternScore(employee, shiftTemplate, workPatterns, previousAssignments, date)
      score += patternScore * 0.85

      // Mentorship pairing score (0-30 points) - NEW: Î©òÌÜ†-Î©òÌã∞ ÌéòÏñ¥ÎßÅ
      const mentorshipScore = this.calculateMentorshipScore(employee, shiftTemplate, dailyAssignments, date)
      score += mentorshipScore

      // Nursing pattern safety score (0-25 points) - ÌïúÍµ≠ Í∞ÑÌò∏ÏÇ¨ ÏúÑÌóò Ìå®ÌÑ¥ ÌöåÌîº
      const nursingPatternScore = this.calculateNursingPatternSafetyScore(employee, shiftTemplate, previousAssignments, date)
      score += nursingPatternScore

      // Fairness score (0-30 points) - Í∞úÏù∏ ÏÑ†Ìò∏ÎèÑ Î∞òÏòÅÌïú Í≥µÏ†ïÏÑ±
      const fairnessScore = this.calculateFairnessScore(employee.id, shiftTemplate, previousAssignments, date)
      score += fairnessScore

      // Organization hierarchy bonus (0-20 points)
      const hierarchyBonus = this.calculateHierarchyBonus(employee, shiftTemplate)
      score += hierarchyBonus

      // Consecutive shift penalty (0-10 points deduction)
      const consecutivePenalty = this.calculateConsecutivePenalty(employee.id, date, previousAssignments)
      score -= consecutivePenalty

      return { employee, score }
    }).sort((a, b) => b.score - a.score)
  }

  /**
   * Select employees ensuring balanced organization hierarchy coverage
   * 3Îã®Í≥Ñ: 1.ÏÑ† ÏöîÍµ¨ÏÇ¨Ìï≠ -> 2.Î†àÎ≤® Î∞∏Îü∞Ïä§ -> 3.ÏÑ†Ìò∏ Ìå®ÌÑ¥
   */
  private async selectEmployeesWithHierarchy(
    scoredEmployees: Array<{ employee: Employee; score: number }>,
    requiredCount: number,
    allEmployees: Employee[],
    teamId?: string
  ): Promise<Employee[]> {
    const selected: Employee[] = []
    
    // Î†àÎ≤®Î≥Ñ ÏßÅÏõê Í∑∏Î£πÌôî Î∞è Ï†ïÎ≥¥ ÏàòÏßë
    const levelGroups = new Map<number, Employee[]>()
    const levelCounts = new Map<number, number>()
    
    scoredEmployees.forEach(({ employee }) => {
      if (!levelGroups.has(employee.level)) {
        levelGroups.set(employee.level, [])
        levelCounts.set(employee.level, 0)
      }
      levelGroups.get(employee.level)!.push(employee)
    })

    const levels = [...levelGroups.keys()].sort((a, b) => b - a) // ÎÜíÏùÄ Î†àÎ≤®Î∂ÄÌÑ∞
    const highestLevel = Math.max(...levels)
    const lowestLevel = Math.min(...levels)
    
    // 1Îã®Í≥Ñ: Í∞Å Î†àÎ≤®ÏóêÏÑú ÏµúÏÜå 1Î™ÖÏî© ÌïÑÏàò ÏÑ†Î∞ú
    console.log(`üìä Level balance check - Required: ${requiredCount}, Levels: ${levels.join(', ')}`)
    
    for (const level of levels) {
      const levelEmployees = scoredEmployees
        .filter(se => se.employee.level === level)
        .sort((a, b) => b.score - a.score)
      
      if (levelEmployees.length > 0 && selected.length < requiredCount) {
        selected.push(levelEmployees[0].employee)
        levelCounts.set(level, 1)
        console.log(`‚úÖ Level ${level} ÌïÑÏàò ÏÑ†Î∞ú: ${levelEmployees[0].employee.name}`)
      }
    }

    // 2Îã®Í≥Ñ: Î†àÎ≤® Î∞∏Îü∞Ïä§ Í≤ÄÏ¶ù Î∞è Ï°∞Ï†ï (ÏÑ†Ìò∏ÎèÑ Î∞òÏòÅ)
    const remainingSlots = requiredCount - selected.length
    if (remainingSlots > 0) {
      const balanceResult = await this.calculateOptimalLevelBalance(
        levelGroups, 
        levelCounts, 
        remainingSlots,
        requiredCount,
        teamId
      )
      
      // Î∞∏Îü∞Ïä§ Í∏∞Ï§ÄÏúºÎ°ú Ï∂îÍ∞Ä ÏÑ†Î∞ú
      for (const level of levels) {
        const targetCount = balanceResult.get(level) || 0
        const currentCount = levelCounts.get(level) || 0
        const needMore = targetCount - currentCount
        
        if (needMore > 0) {
          const availableEmployees = scoredEmployees
            .filter(se => se.employee.level === level && !selected.includes(se.employee))
            .sort((a, b) => b.score - a.score)
            .slice(0, needMore)
          
          availableEmployees.forEach(({ employee }) => {
            if (selected.length < requiredCount) {
              selected.push(employee)
              levelCounts.set(level, (levelCounts.get(level) || 0) + 1)
              console.log(`‚öñÔ∏è Level ${level} Î∞∏Îü∞Ïä§ Ï°∞Ï†ï ÏÑ†Î∞ú: ${employee.name}`)
            }
          })
        }
      }
    }

    // 3Îã®Í≥Ñ: ÎÇ®ÏùÄ ÏûêÎ¶¨Îäî Ï†êÏàòÏàúÏúºÎ°ú Ï±ÑÏö∞Îêò extreme imbalance Î∞©ÏßÄ
    const finalRemaining = requiredCount - selected.length
    if (finalRemaining > 0) {
      const remaining = scoredEmployees
        .filter(se => !selected.includes(se.employee))
        .sort((a, b) => b.score - a.score)

      for (const { employee } of remaining) {
        if (selected.length >= requiredCount) break
        
        // Ï†êÏàòÏàúÏúºÎ°ú ÏÑ†Î∞ú (80% Ï†úÌïú Ï†úÍ±∞)
        selected.push(employee)
        console.log(`üìà Ï†êÏàòÏàú ÏÑ†Î∞ú: ${employee.name} (Level ${employee.level})`)
      }
    }

    // ÏµúÏ¢Ö Î∞∏Îü∞Ïä§ Î¶¨Ìè¨Ìä∏
    const finalDistribution = this.calculateLevelDistribution(selected)
    console.log('üéØ ÏµúÏ¢Ö Î†àÎ≤® Î∂ÑÌè¨:', Object.fromEntries(finalDistribution))
    
    return selected
  }

  /**
   * ÏµúÏ†Å Î†àÎ≤® Î∞∏Îü∞Ïä§ Í≥ÑÏÇ∞
   */
  private async calculateOptimalLevelBalance(
    levelGroups: Map<number, Employee[]>,
    currentCounts: Map<number, number>,
    remainingSlots: number,
    totalRequired: number,
    teamId?: string
  ): Promise<Map<number, number>> {
    const targetCounts = new Map<number, number>()
    const levels = [...levelGroups.keys()].sort((a, b) => b - a)
    
    // Í∞Å Î†àÎ≤®Î≥Ñ Í∞ÄÏö© Ïù∏Ïõê Í≥ÑÏÇ∞
    const availableByLevel = new Map<number, number>()
    levels.forEach(level => {
      const current = currentCounts.get(level) || 0
      const total = levelGroups.get(level)?.length || 0
      availableByLevel.set(level, Math.max(0, total - current))
    })

    // DBÏóêÏÑú ÏÑ§Ï†ïÎêú ÎπÑÏú® Í∞ÄÏ†∏Ïò§Í∏∞ (ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©)
    const ratios = new Map<number, number>()
    
    if (teamId) {
      try {
        const { createClient } = await import('@/lib/supabase/client')
        const supabase = createClient()
        const { data } = await supabase
          .from('organization_hierarchy')
          .select('level, distribution_ratio')
          .eq('team_id', teamId)
          .order('level')
        
        if (data && data.length > 0) {
          data.forEach(item => {
            ratios.set(item.level, item.distribution_ratio || 1)
          })
        }
      } catch (error) {
        console.error('Failed to fetch hierarchy ratios:', error)
      }
    }
    
    // ÎπÑÏú®Ïù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö© (ÌîºÎùºÎØ∏Îìú Íµ¨Ï°∞)
    if (ratios.size === 0) {
      levels.forEach(level => {
        // Î†àÎ≤®Ïù¥ ÎÜíÏùÑÏàòÎ°ù(Ïà´ÏûêÍ∞Ä ÏûëÏùÑÏàòÎ°ù) Ï†ÅÏùÄ ÎπÑÏú®
        // 1Î†àÎ≤®: 1, 2-3Î†àÎ≤®: 2, 4-6Î†àÎ≤®: 3, 7-10Î†àÎ≤®: 4
        let ratio = 1
        if (level >= 7) ratio = 4       // Î†àÎ≤® 7-10: Í∞ÄÏû• ÎßéÏù¥
        else if (level >= 4) ratio = 3  // Î†àÎ≤® 4-6: ÎßéÏù¥
        else if (level >= 2) ratio = 2  // Î†àÎ≤® 2-3: Î≥¥ÌÜµ
        else ratio = 1                  // Î†àÎ≤® 1: Ï†ÅÍ≤å
        
        ratios.set(level, ratio)
      })
    }
    
    // ÎπÑÏú® Ìï©Í≥Ñ
    const totalRatio = Array.from(ratios.values()).reduce((sum, r) => sum + r, 0)
    
    // ÎπÑÏú®Ïóê Îî∞Î•∏ Î∂ÑÎ∞∞
    levels.forEach(level => {
      const ratio = ratios.get(level) || 1
      let target = Math.floor((totalRequired * ratio) / totalRatio)
      
      const available = availableByLevel.get(level) || 0
      const current = currentCounts.get(level) || 0
      
      // Í∞ÄÏö© Ïù∏ÏõêÏùÑ Ï¥àÍ≥ºÌïòÏßÄ ÏïäÎèÑÎ°ù Ï°∞Ï†ï
      target = Math.min(target, current + available)
      targetCounts.set(level, target)
    })
    
    // ÎÇòÎ®∏ÏßÄ Ïù∏Ïõê Î∞∞Ï†ï (Î†àÎ≤® 2,3 Ïö∞ÏÑ†)
    const assignedSoFar = Array.from(targetCounts.values()).reduce((sum, count) => sum + count, 0)
    let leftover = totalRequired - assignedSoFar
    
    // ÎÇÆÏùÄ Î†àÎ≤®(Ïã†ÏûÖ/Ï§ëÍ∞Ñ)Î∂ÄÌÑ∞ Ï∂îÍ∞Ä Î∞∞Ï†ï
    const reversedLevels = [...levels].reverse()
    for (const level of reversedLevels) {
      if (leftover <= 0) break
      const available = availableByLevel.get(level) || 0
      const current = currentCounts.get(level) || 0
      const target = targetCounts.get(level) || 0
      const canAdd = Math.min(leftover, available - (target - current))
      if (canAdd > 0) {
        targetCounts.set(level, target + canAdd)
        leftover -= canAdd
      }
    }

    // Î∞∞Ï†ïÎêòÏßÄ ÏïäÏùÄ Ïä¨Î°ØÏùÑ Îã§Î•∏ Î†àÎ≤®Î°ú Ïû¨Î∞∞Ïπò
    const assignedTotal = Array.from(targetCounts.values()).reduce((sum, count) => sum + count, 0)
    const unassigned = totalRequired - assignedTotal
    
    if (unassigned > 0) {
      // Í∞ÄÏö© Ïù∏ÏõêÏù¥ ÎßéÏùÄ Î†àÎ≤®Î∂ÄÌÑ∞ Ï∂îÍ∞Ä Î∞∞Ï†ï
      const sortedByAvailable = levels
        .map(level => ({ 
          level, 
          available: availableByLevel.get(level) || 0,
          target: targetCounts.get(level) || 0,
          current: currentCounts.get(level) || 0
        }))
        .filter(item => item.available > item.target - item.current)
        .sort((a, b) => b.available - a.available)
      
      let remaining = unassigned
      for (const item of sortedByAvailable) {
        if (remaining <= 0) break
        const canAdd = Math.min(remaining, item.available - (item.target - item.current))
        if (canAdd > 0) {
          targetCounts.set(item.level, item.target + canAdd)
          remaining -= canAdd
        }
      }
    }

    return targetCounts
  }

  /**
   * ÏÑ†Î∞úÎêú ÏßÅÏõêÎì§Ïùò Î†àÎ≤® Î∂ÑÌè¨ Í≥ÑÏÇ∞
   */
  private calculateLevelDistribution(employees: Employee[]): Map<number, number> {
    const distribution = new Map<number, number>()
    employees.forEach(emp => {
      distribution.set(emp.level, (distribution.get(emp.level) || 0) + 1)
    })
    return distribution
  }

  /**
   * Calculate nursing pattern safety score - ÌïúÍµ≠ Í∞ÑÌò∏ÏÇ¨ ÏúÑÌóò Ìå®ÌÑ¥ ÌöåÌîº
   */
  private calculateNursingPatternSafetyScore(
    employee: Employee,
    shiftTemplate: ShiftTemplate,
    previousAssignments: GeneratedAssignment[],
    date: string
  ): number {
    // ÏµúÍ∑º 14ÏùºÍ∞ÑÏùò Î∞∞Ï†ï Ïù¥Î†• Í∞ÄÏ†∏Ïò§Í∏∞
    const recentAssignments = this.getRecentAssignments(employee.id, date, previousAssignments, 14)
    
    // Í∞ÄÏÉÅÏùò Î∞∞Ï†ïÏùÑ Ï∂îÍ∞ÄÌï¥ÏÑú Ìå®ÌÑ¥ Î∂ÑÏÑù
    const testAssignments = [
      ...recentAssignments.map(a => ({
        date: a.date,
        shift_type: a.shift_template_id.includes('day') ? 'day' :
                   a.shift_template_id.includes('evening') ? 'evening' :
                   a.shift_template_id.includes('night') ? 'night' : 'off',
        leave_type: undefined
      })),
      {
        date: date,
        shift_type: shiftTemplate.type,
        leave_type: undefined
      }
    ]

    // ÏúÑÌóò Ìå®ÌÑ¥ Í∞êÏßÄ
    let safetyScore = 25 // Í∏∞Î≥∏ ÎßåÏ†ê

    // 1. Ïó∞ÏÜç 3ÍµêÎåÄ Ìå®ÌÑ¥ Ï≤¥ÌÅ¨ (ÏµúÎåÄ -15Ï†ê)
    const hasTripleShiftPattern = this.checkTripleShiftPattern(testAssignments, date)
    if (hasTripleShiftPattern) {
      safetyScore -= 15
      console.log(`‚ùå Triple shift pattern detected for ${employee.name} on ${date}`)
    }

    // 2. Ïó∞ÏÜç ÎÇòÏù¥Ìä∏ Í≥ºÎã§ Ï≤¥ÌÅ¨ (ÏµúÎåÄ -10Ï†ê)
    const consecutiveNights = this.countConsecutiveNights(testAssignments, date)
    if (consecutiveNights >= 4) {
      safetyScore -= 10
      console.log(`‚ö†Ô∏è Excessive consecutive nights (${consecutiveNights}) for ${employee.name}`)
    } else if (consecutiveNights === 3 && shiftTemplate.type === 'night') {
      safetyScore -= 5 // 4Î≤àÏß∏ ÎÇòÏù¥Ìä∏Î©¥ ÏïΩÍ∞Ñ Í∞êÏ†ê
    }

    // 3. Î≤àÍ∞àÏïÑ Ìå®ÌÑ¥ Ï≤¥ÌÅ¨ (ÏµúÎåÄ -8Ï†ê)
    const hasAlternatingPattern = this.checkAlternatingPattern(testAssignments)
    if (hasAlternatingPattern) {
      safetyScore -= 8
      console.log(`üîÑ Alternating pattern detected for ${employee.name}`)
    }

    // 4. ÎçîÎ∏î Í∑ºÎ¨¥ ÌõÑ Î∂àÏ∂©Î∂ÑÌïú Ìú¥Ïãù Ï≤¥ÌÅ¨ (ÏµúÎåÄ -7Ï†ê)
    const hasDoubleWithoutRest = this.checkDoubleWithoutRest(testAssignments, date)
    if (hasDoubleWithoutRest) {
      safetyScore -= 7
      console.log(`üí™ Double shift without proper rest for ${employee.name}`)
    }

    // 5. Ï£ºÎßê ÎÇòÏù¥Ìä∏ Í∞ÄÏ§ëÏπò (ÏµúÎåÄ -5Ï†ê)
    const isWeekendNight = this.isWeekendNight(date, shiftTemplate.type)
    if (isWeekendNight) {
      safetyScore -= 3
    }

    return Math.max(0, safetyScore)
  }

  /**
   * Ïó∞ÏÜç 3ÍµêÎåÄ Ìå®ÌÑ¥ Ï≤¥ÌÅ¨ (D-E-N, N-D-E Îì±)
   */
  private checkTripleShiftPattern(assignments: Array<{ date: string; shift_type: string }>, targetDate: string): boolean {
    const sortedAssignments = assignments.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
    
    // ÏµúÍ∑º 3Ïùº Ï≤¥ÌÅ¨
    for (let i = 0; i <= sortedAssignments.length - 3; i++) {
      const threeDay = sortedAssignments.slice(i, i + 3)
      
      // 3ÏùºÏù¥ Ïó∞ÏÜçÏù∏ÏßÄ ÌôïÏù∏
      const dates = threeDay.map(a => new Date(a.date))
      let isConsecutive = true
      for (let j = 1; j < dates.length; j++) {
        const dayDiff = (dates[j].getTime() - dates[j-1].getTime()) / (1000 * 60 * 60 * 24)
        if (dayDiff !== 1) {
          isConsecutive = false
          break
        }
      }
      
      if (isConsecutive) {
        const shifts = threeDay.map(a => a.shift_type).filter(s => s !== 'off')
        if (shifts.length === 3) {
          const uniqueShifts = new Set(shifts)
          // 3Í∞úÏùò ÏÑúÎ°ú Îã§Î•∏ ÏãúÌîÑÌä∏Í∞Ä ÎÇòÏò§Î©¥ ÏúÑÌóò
          if (uniqueShifts.size === 3 && 
              uniqueShifts.has('day') && 
              uniqueShifts.has('evening') && 
              uniqueShifts.has('night')) {
            return true
          }
        }
      }
    }
    
    return false
  }

  /**
   * Ïó∞ÏÜç ÎÇòÏù¥Ìä∏ Ïàò Í≥ÑÏÇ∞
   */
  private countConsecutiveNights(assignments: Array<{ date: string; shift_type: string }>, targetDate: string): number {
    const sortedAssignments = assignments
      .filter(a => new Date(a.date) <= new Date(targetDate))
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    
    let consecutiveNights = 0
    const targetDateObj = new Date(targetDate)
    
    for (let i = 0; i < sortedAssignments.length; i++) {
      const assignmentDate = new Date(sortedAssignments[i].date)
      const expectedDate = new Date(targetDateObj)
      expectedDate.setDate(expectedDate.getDate() - i)
      
      if (assignmentDate.getTime() === expectedDate.getTime() && 
          sortedAssignments[i].shift_type === 'night') {
        consecutiveNights++
      } else {
        break
      }
    }
    
    return consecutiveNights
  }

  /**
   * Î≤àÍ∞àÏïÑ Ìå®ÌÑ¥ Ï≤¥ÌÅ¨ (D-Off-N-Off-E Îì±)
   */
  private checkAlternatingPattern(assignments: Array<{ date: string; shift_type: string }>): boolean {
    const workDays = assignments.filter(a => a.shift_type !== 'off')
    
    if (workDays.length < 3) return false
    
    // ÏµúÍ∑º 5Ïùº Ï§ë 3Í∞ú Ïù¥ÏÉÅÏùò ÏÑúÎ°ú Îã§Î•∏ ÏãúÌîÑÌä∏Í∞Ä Î≤àÍ∞àÏïÑ ÎÇòÏò§ÎäîÏßÄ Ï≤¥ÌÅ¨
    const recentWork = workDays.slice(-5)
    const shiftTypes = recentWork.map(a => a.shift_type)
    const uniqueShifts = new Set(shiftTypes)
    
    if (uniqueShifts.size >= 3) {
      // Ïó∞ÏÜçÏÑ±Ïù¥ ÏóÜÎäî Ìå®ÌÑ¥Ïù∏ÏßÄ Ï≤¥ÌÅ¨
      let isAlternating = true
      for (let i = 1; i < shiftTypes.length; i++) {
        if (shiftTypes[i] === shiftTypes[i - 1]) {
          isAlternating = false
          break
        }
      }
      return isAlternating
    }
    
    return false
  }

  /**
   * ÎçîÎ∏î Í∑ºÎ¨¥ ÌõÑ Î∂àÏ∂©Î∂ÑÌïú Ìú¥Ïãù Ï≤¥ÌÅ¨
   */
  private checkDoubleWithoutRest(assignments: Array<{ date: string; shift_type: string }>, targetDate: string): boolean {
    const sortedAssignments = assignments.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
    
    // ÏµúÍ∑º 4Ïùº Ìå®ÌÑ¥ Ï≤¥ÌÅ¨
    for (let i = 0; i <= sortedAssignments.length - 4; i++) {
      const fourDay = sortedAssignments.slice(i, i + 4)
      
      // ÎçîÎ∏î Ìå®ÌÑ¥ + 1Ïùº Ìú¥Ïãù + Í∑ºÎ¨¥ Î≥µÍ∑Ä Ï≤¥ÌÅ¨
      const isDouble = (
        (fourDay[0].shift_type === 'day' && fourDay[1].shift_type === 'evening') ||
        (fourDay[0].shift_type === 'evening' && fourDay[1].shift_type === 'night')
      )
      
      if (isDouble && 
          fourDay[2].shift_type === 'off' && 
          fourDay[3].shift_type !== 'off' &&
          fourDay[3].date === targetDate) {
        return true
      }
    }
    
    return false
  }

  /**
   * Ï£ºÎßê ÎÇòÏù¥Ìä∏ Ïó¨Î∂Ä Ï≤¥ÌÅ¨
   */
  private isWeekendNight(date: string, shiftType: string): boolean {
    if (shiftType !== 'night') return false
    
    const dateObj = new Date(date)
    const dayOfWeek = dateObj.getDay()
    
    // Í∏àÏöîÏùº(5) ÎÇòÏù¥Ìä∏ ÎòêÎäî ÌÜ†ÏöîÏùº(6) ÎÇòÏù¥Ìä∏
    return dayOfWeek === 5 || dayOfWeek === 6
  }

  /**
   * Calculate work pattern score - ÏßßÏùÄ/Í∏¥ Í∑ºÎ¨¥ Ìå®ÌÑ¥ ÏÑ†Ìò∏ÎèÑ Î∞òÏòÅ
   */
  private calculateWorkPatternScore(
    employee: Employee,
    shiftTemplate: ShiftTemplate,
    workPatterns: Map<string, WorkPatternPreference>,
    previousAssignments: GeneratedAssignment[],
    date: string
  ): number {
    const pattern = workPatterns.get(employee.id)
    if (!pattern) return 15 // Neutral score if no pattern set

    // Get recent assignments for this employee to analyze current work streak
    const recentAssignments = this.getRecentAssignments(employee.id, date, previousAssignments, 14)
    
    // Create assignment object for pattern scoring
    const assignment = {
      date,
      shift_type: shiftTemplate.type
    }

    // Use the pattern scoring function from work-pattern-types.ts
    const patternScore = calculatePatternScore(employee, assignment, recentAssignments, pattern)
    
    // Scale the score from 0-100 to 0-35 points
    return (patternScore / 100) * 35
  }

  /**
   * Calculate preference score for employee and shift
   */
  private calculatePreferenceScore(
    employeeId: string,
    shiftTemplate: ShiftTemplate,
    preferences: Map<string, EmployeePreference[]>,
    date: string
  ): number {
    const empPreferences = preferences.get(employeeId) || []
    if (empPreferences.length === 0) return 20 // Neutral score

    const dateObj = new Date(date)
    const dayOfWeek = dateObj.getDay()
    
    // Find the most recent active preference
    const activePrefs = empPreferences.filter(pref => {
      const effectiveFrom = new Date(pref.effective_from)
      const effectiveTo = pref.effective_to ? new Date(pref.effective_to) : new Date('2099-12-31')
      return dateObj >= effectiveFrom && dateObj <= effectiveTo
    })

    if (activePrefs.length === 0) return 20

    const preference = activePrefs[0]
    const patternLength = preference.preference_pattern.length
    const patternIndex = dayOfWeek % patternLength
    const preferredShift = preference.preference_pattern[patternIndex]

    // Perfect match
    if (preferredShift === shiftTemplate.type) {
      return 40
    }

    // Partial match logic
    if (preferredShift === 'off' && shiftTemplate.type !== 'night') {
      return 10 // Slight preference for non-night when wanting off
    }

    return 5 // Low score for non-matching shifts
  }

  /**
   * Calculate fairness score based on employee preference and balance
   * Í∞úÏù∏ ÏÑ†Ìò∏ÎèÑÎ•º Î∞òÏòÅÌïú ÏßÑÏ†ïÌïú Í≥µÏ†ïÏÑ± Í≥ÑÏÇ∞
   */
  private calculateFairnessScore(
    employeeId: string, 
    shiftTemplate: ShiftTemplate,
    previousAssignments: GeneratedAssignment[],
    date: string
  ): number {
    // Get employee's lifestyle preference from cache
    const preference = this.cachedEmployeePreferences?.get(employeeId)?.[0]
    const lifestylePreference = preference?.lifestyle_preference || 'flexible'
    const fairnessOption = preference?.fairness_option || 'auto'
    
    // Get fairness ledger for this month
    const currentMonth = new Date(date).toISOString().slice(0, 7)
    const fairnessBalance = this.cachedFairnessLedger?.get(employeeId)?.balance_score || 0
    
    let baseScore = 20 // Í∏∞Î≥∏ Ï†êÏàò
    
    // 1. ÏÑ†Ìò∏ÎèÑ Í∏∞Î∞ò Í≥µÏ†ïÏÑ±
    if (lifestylePreference === 'night_owl') {
      // ÏïºÍ∞Ñ ÏÑ†Ìò∏ÏûêÏóêÍ≤å ÏïºÍ∞ÑÏùÄ Í≥µÏ†ï, DayÎäî Î∂àÍ≥µÏ†ï
      if (shiftTemplate.type === 'night') {
        baseScore += 10 // ÏÑ†Ìò∏ ÏãúÍ∞ÑÎåÄ = Í≥µÏ†ï
      } else if (shiftTemplate.type === 'day') {
        baseScore -= 5  // ÎπÑÏÑ†Ìò∏ ÏãúÍ∞ÑÎåÄ = Î∂àÍ≥µÏ†ï
      }
    } else if (lifestylePreference === 'morning_person') {
      // Ï£ºÍ∞Ñ ÏÑ†Ìò∏ÏûêÏóêÍ≤å DayÎäî Í≥µÏ†ï, NightÎäî Î∂àÍ≥µÏ†ï
      if (shiftTemplate.type === 'day') {
        baseScore += 10
      } else if (shiftTemplate.type === 'night') {
        baseScore -= 5
      }
    }
    // flexibleÏùÄ Î™®Îì† ÏãúÍ∞ÑÎåÄ Ï§ëÎ¶ΩÏ†Å
    
    // 2. Í≥µÏ†ïÏÑ± ÏòµÏÖò Î∞òÏòÅ
    if (fairnessOption === 'prefer_my_preference') {
      // Í∞úÏù∏ ÏÑ†Ìò∏ ÏµúÏö∞ÏÑ† - ÏÑ†Ìò∏ÎèÑ Ï†êÏàò Ï∂îÍ∞Ä
      const isPreferred = this.isPreferredShift(employeeId, shiftTemplate.type)
      if (isPreferred) baseScore += 5
    } else if (fairnessOption === 'prefer_team_balance') {
      // ÌåÄ Í∑†Ìòï Ïö∞ÏÑ† - Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ
      const employeeAssignments = previousAssignments.filter(a => a.employee_id === employeeId)
      const avgAssignments = previousAssignments.length / new Set(previousAssignments.map(a => a.employee_id)).size
      if (employeeAssignments.length < avgAssignments * 0.9) {
        baseScore += 5 // Ï†ÅÍ≤å ÏùºÌïú ÏÇ¨Îûå Ïö∞ÏÑ†
      }
    }
    
    // 3. ÎàÑÏ†Å Í≥µÏ†ïÏÑ± Î∞∏Îü∞Ïä§ Î∞òÏòÅ
    if (fairnessBalance > 10) {
      // ÌòúÌÉùÏùÑ ÎßéÏù¥ Î∞õÏùÄ ÏÇ¨ÎûåÏùÄ Í∞êÏ†ê
      baseScore -= Math.min(10, fairnessBalance / 2)
    } else if (fairnessBalance < -10) {
      // Í∏∞Ïó¨Î•º ÎßéÏù¥ Ìïú ÏÇ¨ÎûåÏùÄ Í∞ÄÏ†ê
      baseScore += Math.min(10, Math.abs(fairnessBalance) / 2)
    }
    
    // 4. ÌäπÎ≥Ñ Í∏∞Ïó¨ Î≥¥ÎÑàÏä§
    const recentWeekendNights = this.countRecentWeekendNights(employeeId, previousAssignments, 30)
    if (recentWeekendNights >= 2) {
      baseScore += 5 // ÏµúÍ∑º Ï£ºÎßê ÏïºÍ∞Ñ ÎßéÏù¥ Ìïú ÏÇ¨Îûå Î≥¥ÏÉÅ
    }
    
    return Math.max(0, Math.min(30, baseScore))
  }
  
  /**
   * Check if shift type is preferred by employee
   */
  private isPreferredShift(employeeId: string, shiftType: string): boolean {
    const preference = this.cachedEmployeePreferences?.get(employeeId)?.[0]
    if (!preference) return false
    
    if (preference.lifestyle_preference === 'night_owl') {
      return shiftType === 'night' || shiftType === 'evening'
    } else if (preference.lifestyle_preference === 'morning_person') {
      return shiftType === 'day'
    }
    return true // flexibleÏùÄ Î™®Îëê ÏÑ†Ìò∏
  }
  
  /**
   * Count recent weekend night shifts
   */
  private countRecentWeekendNights(
    employeeId: string,
    assignments: GeneratedAssignment[],
    days: number
  ): number {
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - days)
    
    return assignments.filter(a => {
      if (a.employee_id !== employeeId) return false
      const assignmentDate = new Date(a.date)
      if (assignmentDate < cutoffDate) return false
      const dayOfWeek = assignmentDate.getDay()
      return (dayOfWeek === 5 || dayOfWeek === 6) && 
             a.shift_template_id.includes('night')
    }).length
  }

  /**
   * Calculate hierarchy bonus
   */
  private calculateHierarchyBonus(employee: Employee, shiftTemplate: ShiftTemplate): number {
    // Higher level employees get slight bonus for critical shifts
    if (shiftTemplate.type === 'night' || shiftTemplate.name.includes('supervisor')) {
      return Math.min(employee.level * 5, 20)
    }
    return employee.level * 2
  }

  /**
   * Calculate consecutive shift penalty
   */
  private calculateConsecutivePenalty(
    employeeId: string,
    date: string,
    previousAssignments: GeneratedAssignment[]
  ): number {
    const recentAssignments = this.getRecentAssignments(employeeId, date, previousAssignments, 7)
    const consecutiveDays = this.countConsecutiveDays(recentAssignments, date)

    if (consecutiveDays >= 5) return 10
    if (consecutiveDays >= 3) return 5
    return 0
  }

  /**
   * Calculate mentorship pairing score
   * Î©òÌÜ†-Î©òÌã∞ ÌéòÏñ¥ÎßÅ Ï†êÏàò (Í≥µÏ†ïÏÑ±Í≥º Í∑†ÌòïÏûàÍ≤å Ï°∞Ï†ï)
   */
  private calculateMentorshipScore(
    employee: Employee,
    shiftTemplate: ShiftTemplate,
    dailyAssignments: GeneratedAssignment[],
    date: string
  ): number {
    let score = 0

    // Get active mentorship relationships from cache
    const mentorships = this.cachedMentorships || []
    const requirements = this.cachedMentoringRequirements
    
    // Î©òÌÜ†Ïã≠Ïù¥ ÏóÜÏúºÎ©¥ 0Ï†ê (Î∂àÏù¥Ïùµ ÏóÜÏùå)
    if (mentorships.length === 0) return 0

    // Check if employee is a mentee
    const asMentee = mentorships.find(m => 
      m.mentee_id === employee.id && 
      m.status === 'active' &&
      this.isDateInMentorshipPeriod(date, m)
    )

    if (asMentee) {
      // Check if mentor is already assigned to this shift
      const mentorAssignment = dailyAssignments.find(
        a => a.employee_id === asMentee.mentor_id && 
             a.shift_template_id === shiftTemplate.id
      )

      if (mentorAssignment) {
        // Î©òÌÜ†ÏôÄ Í∞ôÏùÄ ÏãúÌîÑÌä∏ - Ï†ÅÏ†àÌïú Î≥¥ÎÑàÏä§ (Í≥ºÎèÑÌïòÏßÄ ÏïäÍ≤å)
        score += 15 * (asMentee.pairing_strength / 10)
        console.log(`üë• Mentee ${employee.name} matched with mentor (+${score} points)`)
      } else if (requirements?.same_shift_required && asMentee.pairing_strength >= 7) {
        // ÌïÑÏàò ÌéòÏñ¥ÎßÅÏù∏Îç∞ Î©òÌÜ† ÎØ∏Î∞∞Ï†ï Ïãú ÏïΩÍ∞ÑÏùò Ìå®ÎÑêÌã∞
        score -= 3
      }
      // Î©òÌÜ†Ïã≠Ïù¥ ÏûàÏñ¥ÎèÑ Ï§ëÎ¶ΩÏ†Å Ï†êÏàò Ïú†ÏßÄ Í∞ÄÎä•
    }

    // Check if employee is a mentor
    const asMentor = mentorships.filter(m => 
      m.mentor_id === employee.id && 
      m.status === 'active' &&
      this.isDateInMentorshipPeriod(date, m)
    )

    if (asMentor.length > 0) {
      // Check how many mentees are already in this shift
      const menteesInShift = asMentor.filter(m => {
        const menteeAssignment = dailyAssignments.find(
          a => a.employee_id === m.mentee_id && 
               a.shift_template_id === shiftTemplate.id
        )
        return menteeAssignment !== undefined
      })

      if (menteesInShift.length > 0) {
        // Î©òÌã∞ÏôÄ Ìï®Íªò - Ï†ÅÏ†àÌïú Î≥¥ÎÑàÏä§
        score += 10 * (menteesInShift.length / asMentor.length)
        console.log(`üë®‚Äçüè´ Mentor ${employee.name} with ${menteesInShift.length} mentees (+${score} points)`)
      }
    }

    // ÏµúÎåÄ 15Ï†êÏúºÎ°ú Ï†úÌïú (Í≥µÏ†ïÏÑ± Ï†êÏàò 30Ï†êÎ≥¥Îã§ ÎÇÆÍ≤å)
    return Math.max(-5, Math.min(15, score))
  }

  /**
   * Check if date is within mentorship period
   */
  private isDateInMentorshipPeriod(date: string, mentorship: MentorshipRelationship): boolean {
    const checkDate = new Date(date)
    const startDate = new Date(mentorship.start_date)
    const endDate = mentorship.end_date ? new Date(mentorship.end_date) : new Date('2099-12-31')
    
    return checkDate >= startDate && checkDate <= endDate
  }

  /**
   * Helper methods for constraints and rules
   */
  private violatesConstraint(
    constraint: EmployeeConstraint,
    shiftTemplate: ShiftTemplate,
    date: string
  ): boolean {
    const constraintDate = new Date(date)
    const effectiveFrom = new Date(constraint.effective_from)
    const effectiveTo = constraint.effective_to ? new Date(constraint.effective_to) : new Date('2099-12-31')

    if (constraintDate < effectiveFrom || constraintDate > effectiveTo) {
      return false
    }

    switch (constraint.constraint_type) {
      case 'no_night':
        return shiftTemplate.type === 'night'
      
      case 'fixed_day':
        const fixedDayData = constraint.constraint_value as { day_of_week: number; shift_type: string }
        return constraintDate.getDay() === fixedDayData.day_of_week && 
               shiftTemplate.type !== fixedDayData.shift_type
      
      case 'time_off':
        // Assuming constraint_value contains start and end dates
        const timeOffData = constraint.constraint_value as { start_date: string; end_date: string }
        const timeOffStart = new Date(timeOffData.start_date)
        const timeOffEnd = new Date(timeOffData.end_date)
        return constraintDate >= timeOffStart && constraintDate <= timeOffEnd

      default:
        return false
    }
  }

  private hasMinimumRestHours(
    employeeId: string,
    date: string,
    shiftTemplate: ShiftTemplate,
    previousAssignments: GeneratedAssignment[]
  ): boolean {
    const currentDate = new Date(date)
    const previousDay = new Date(currentDate)
    previousDay.setDate(previousDay.getDate() - 1)
    const previousDayStr = previousDay.toISOString().split('T')[0]

    const lastAssignment = previousAssignments.find(
      a => a.employee_id === employeeId && a.date === previousDayStr
    )

    if (!lastAssignment) return true

    // Calculate hours between end of last shift and start of new shift
    const lastEndTime = new Date(`${lastAssignment.date}T${lastAssignment.end_time}`)
    const newStartTime = new Date(`${date}T${shiftTemplate.start_time}`)

    // Handle overnight shifts
    if (lastEndTime > newStartTime) {
      newStartTime.setDate(newStartTime.getDate() + 1)
    }

    const restHours = (newStartTime.getTime() - lastEndTime.getTime()) / (1000 * 60 * 60)
    return restHours >= 11 // Minimum 11 hours rest
  }

  private exceedsMaxConsecutiveNights(
    employeeId: string,
    date: string,
    previousAssignments: GeneratedAssignment[]
  ): boolean {
    const recentNightShifts = this.getRecentNightShifts(employeeId, date, previousAssignments, 7)
    return recentNightShifts >= 3 // Max 3 consecutive nights
  }

  private getRecentNightShifts(
    employeeId: string,
    date: string,
    previousAssignments: GeneratedAssignment[],
    lookbackDays: number
  ): number {
    const currentDate = new Date(date)
    let consecutiveNights = 0

    for (let i = 1; i <= lookbackDays; i++) {
      const checkDate = new Date(currentDate)
      checkDate.setDate(checkDate.getDate() - i)
      const checkDateStr = checkDate.toISOString().split('T')[0]

      const assignment = previousAssignments.find(
        a => a.employee_id === employeeId && a.date === checkDateStr
      )

      if (assignment && assignment.shift_template_id.includes('night')) {
        consecutiveNights++
      } else {
        break // Not consecutive
      }
    }

    return consecutiveNights
  }

  private getRecentAssignments(
    employeeId: string,
    date: string,
    previousAssignments: GeneratedAssignment[],
    lookbackDays: number
  ): GeneratedAssignment[] {
    const currentDate = new Date(date)
    const assignments: GeneratedAssignment[] = []

    for (let i = 1; i <= lookbackDays; i++) {
      const checkDate = new Date(currentDate)
      checkDate.setDate(checkDate.getDate() - i)
      const checkDateStr = checkDate.toISOString().split('T')[0]

      const assignment = previousAssignments.find(
        a => a.employee_id === employeeId && a.date === checkDateStr
      )

      if (assignment) {
        assignments.push(assignment)
      }
    }

    return assignments.reverse() // Oldest first
  }

  private countConsecutiveDays(assignments: GeneratedAssignment[], currentDate: string): number {
    if (assignments.length === 0) return 0

    const sortedAssignments = assignments.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    const currentDateObj = new Date(currentDate)
    let consecutive = 0

    for (let i = 0; i < sortedAssignments.length; i++) {
      const assignmentDate = new Date(sortedAssignments[i].date)
      const expectedDate = new Date(currentDateObj)
      expectedDate.setDate(expectedDate.getDate() - (i + 1))

      if (assignmentDate.getTime() === expectedDate.getTime()) {
        consecutive++
      } else {
        break
      }
    }

    return consecutive
  }

  private isOvertime(employeeId: string, date: string, previousAssignments: GeneratedAssignment[]): boolean {
    const currentWeekStart = this.getWeekStart(new Date(date))
    const weeklyHours = previousAssignments
      .filter(a => {
        const assignmentDate = new Date(a.date)
        return a.employee_id === employeeId && 
               assignmentDate >= currentWeekStart &&
               assignmentDate < new Date(currentWeekStart.getTime() + 7 * 24 * 60 * 60 * 1000)
      })
      .length * 8 // Assuming 8-hour shifts

    return weeklyHours + 8 > 52 // Over 52 hours per week
  }

  private getWeekStart(date: Date): Date {
    const weekStart = new Date(date)
    weekStart.setDate(date.getDate() - date.getDay() + 1) // Monday
    weekStart.setHours(0, 0, 0, 0)
    return weekStart
  }

  private calculateConfidenceScore(
    employee: Employee,
    shiftTemplate: ShiftTemplate,
    preferences: Map<string, EmployeePreference[]>,
    workPatterns?: Map<string, WorkPatternPreference>
  ): number {
    // Base confidence
    let confidence = 0.7

    // Boost for preference match
    const empPrefs = preferences.get(employee.id) || []
    if (empPrefs.length > 0) {
      // Simplified preference matching
      confidence += 0.15
    }

    // Boost for work pattern match
    if (workPatterns) {
      const pattern = workPatterns.get(employee.id)
      if (pattern) {
        // Check if shift type matches pattern preferences
        const shiftPreference = pattern.shift_type_preferences[shiftTemplate.type as keyof typeof pattern.shift_type_preferences]
        if (shiftPreference && shiftPreference >= 7) {
          confidence += 0.1
        }
      }
    }

    // Boost for hierarchy match
    if ((shiftTemplate.type === 'night' && employee.level >= 2) ||
        (shiftTemplate.type !== 'night' && employee.level >= 1)) {
      confidence += 0.1
    }

    return Math.min(confidence, 1.0)
  }

  private sortShiftsByPriority(shiftTemplates: ShiftTemplate[]): ShiftTemplate[] {
    return shiftTemplates.sort((a, b) => {
      // Night shifts have highest priority due to safety requirements
      const priorityOrder = { 'night': 3, 'evening': 2, 'day': 1, 'off': 0 }
      return (priorityOrder[b.type] || 0) - (priorityOrder[a.type] || 0)
    })
  }

  private optimizeSchedule(
    assignments: GeneratedAssignment[],
    employees: Employee[],
    rules: ScheduleRule[]
  ): GeneratedAssignment[] {
    // Simple optimization: try to balance work hours
    const employeeHours = new Map<string, number>()
    
    assignments.forEach(assignment => {
      const current = employeeHours.get(assignment.employee_id) || 0
      employeeHours.set(assignment.employee_id, current + 8)
    })

    // Calculate target hours per employee
    const totalHours = assignments.length * 8
    const targetHoursPerEmployee = totalHours / employees.length

    // Identify overworked and underworked employees
    const overworked = Array.from(employeeHours.entries())
      .filter(([_, hours]) => hours > targetHoursPerEmployee * 1.2)
      .map(([id]) => id)

    const underworked = Array.from(employeeHours.entries())
      .filter(([_, hours]) => hours < targetHoursPerEmployee * 0.8)
      .map(([id]) => id)

    // Try to swap assignments between overworked and underworked
    // This is a simplified optimization - in practice, you'd want more sophisticated algorithms
    
    return assignments
  }

  /**
   * Fetch employee preferences from database
   */
  private async getEmployeePreferences(employeeIds: string[]): Promise<Map<string, EmployeePreference[]>> {
    const { data: preferences } = await this.supabase
      .from('employee_preferences')
      .select('*')
      .in('employee_id', employeeIds)

    const prefMap = new Map<string, EmployeePreference[]>()
    
    preferences?.forEach((pref: any) => {
      const existing = prefMap.get(pref.employee_id) || []
      existing.push(pref)
      prefMap.set(pref.employee_id, existing)
    })

    // Cache for use in scoring
    this.cachedEmployeePreferences = prefMap
    return prefMap
  }
  
  /**
   * Fetch fairness ledger for current month
   */
  private async getFairnessLedger(employeeIds: string[], month: string): Promise<Map<string, any>> {
    const { data: ledgers } = await this.supabase
      .from('employee_fairness_ledger')
      .select('*')
      .in('employee_id', employeeIds)
      .eq('month', month)

    const ledgerMap = new Map<string, any>()
    
    ledgers?.forEach((ledger: any) => {
      ledgerMap.set(ledger.employee_id, ledger)
    })

    // Cache for use in scoring
    this.cachedFairnessLedger = ledgerMap
    return ledgerMap
  }

  /**
   * Fetch employee constraints from database
   */
  private async getEmployeeConstraints(employeeIds: string[]): Promise<Map<string, EmployeeConstraint[]>> {
    const { data: constraints } = await this.supabase
      .from('employee_constraints')
      .select('*')
      .in('employee_id', employeeIds)

    const constraintMap = new Map<string, EmployeeConstraint[]>()
    
    constraints?.forEach((constraint: any) => {
      const existing = constraintMap.get(constraint.employee_id) || []
      existing.push(constraint)
      constraintMap.set(constraint.employee_id, existing)
    })

    return constraintMap
  }

  /**
   * Fetch work pattern preferences from database
   */
  private async getWorkPatternPreferences(employeeIds: string[]): Promise<Map<string, WorkPatternPreference>> {
    const { data: patterns } = await this.supabase
      .from('work_pattern_preferences')
      .select('*')
      .in('employee_id', employeeIds)

    const patternMap = new Map<string, WorkPatternPreference>()
    
    patterns?.forEach((pattern: any) => {
      patternMap.set(pattern.employee_id, pattern)
    })

    return patternMap
  }

  /**
   * ÌôúÏÑ±ÌôîÎêú ÏÇ¨Ï†Ñ ÏöîÏ≤≠ÏÇ¨Ìï≠ Ï°∞Ìöå
   */
  private async getActiveDefaultRequests(tenantId: string, startDate: string, endDate: string): Promise<any[]> {
    const { data: requests, error } = await this.supabase
      .from('default_requests')
      .select(`
        *,
        employees(id, name, level)
      `)
      .eq('tenant_id', tenantId)
      .eq('status', 'approved')
      .eq('auto_apply', true)
      .or(`
        and(is_recurring.eq.false, specific_date.gte.${startDate}, specific_date.lte.${endDate}),
        and(is_recurring.eq.true, start_date.lte.${endDate}, or(end_date.gte.${startDate}, end_date.is.null))
      `)

    if (error) {
      console.error('Error fetching default requests:', error)
      return []
    }

    return requests || []
  }

  /**
   * ÏÇ¨Ï†Ñ ÏöîÏ≤≠ÏÇ¨Ìï≠ Ï≤òÎ¶¨ (Í≥†Ï†ï Í∑ºÎ¨¥, Ìú¥Í∞Ä Îì±)
   */
  private async processDefaultRequests(
    date: string,
    employees: Employee[],
    shiftTemplates: ShiftTemplate[],
    defaultRequests: any[],
    dailyAssignments: GeneratedAssignment[]
  ): Promise<string[]> {
    const processedEmployeeIds: string[] = []
    const dateObj = new Date(date)
    const dayOfWeek = dateObj.getDay()

    console.log(`üìã Processing ${defaultRequests.length} default requests for ${date}`)

    // Ïö∞ÏÑ†ÏàúÏúÑÎ≥ÑÎ°ú Ï†ïÎ†¨ (1Ïù¥ Í∞ÄÏû• ÎÜíÏùå)
    const sortedRequests = defaultRequests.sort((a, b) => a.priority - b.priority)

    for (const request of sortedRequests) {
      const employeeId = request.employee_id
      
      // Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú ÏßÅÏõêÏùÄ Í±¥ÎÑàÎõ∞Í∏∞
      if (processedEmployeeIds.includes(employeeId)) {
        console.log(`‚è≠Ô∏è Employee ${employeeId} already processed`)
        continue
      }

      // Ìï¥Îãπ ÎÇ†ÏßúÏóê Ï†ÅÏö©ÎêòÎäîÏßÄ ÌôïÏù∏
      if (!this.isRequestApplicableOnDate(request, date, dayOfWeek)) {
        continue
      }

      const employee = employees.find(e => e.id === employeeId)
      if (!employee) {
        console.log(`‚ùå Employee ${employeeId} not found`)
        continue
      }

      try {
        const assigned = await this.applyDefaultRequest(
          request, 
          employee, 
          shiftTemplates, 
          date, 
          dailyAssignments
        )

        if (assigned) {
          processedEmployeeIds.push(employeeId)
          console.log(`‚úÖ Default request applied: ${employee.name} -> ${request.request_type}`)
        }
      } catch (error) {
        console.error(`‚ùå Failed to apply default request for ${employee.name}:`, error)
      }
    }

    return processedEmployeeIds
  }

  /**
   * ÌäπÏ†ï ÎÇ†ÏßúÏóê ÏöîÏ≤≠Ïù¥ Ï†ÅÏö©ÎêòÎäîÏßÄ ÌôïÏù∏
   */
  private isRequestApplicableOnDate(request: any, date: string, dayOfWeek: number): boolean {
    const dateObj = new Date(date)

    // ÌäπÏ†ï ÎÇ†Ïßú ÏöîÏ≤≠
    if (!request.is_recurring && request.specific_date) {
      return request.specific_date === date
    }

    // Î∞òÎ≥µ ÏöîÏ≤≠
    if (request.is_recurring && request.day_of_week !== null) {
      if (request.day_of_week !== dayOfWeek) {
        return false
      }

      // Ï†ÅÏö© Í∏∞Í∞Ñ ÌôïÏù∏
      if (request.start_date && dateObj < new Date(request.start_date)) {
        return false
      }
      if (request.end_date && dateObj > new Date(request.end_date)) {
        return false
      }

      return true
    }

    return false
  }

  /**
   * ÏÇ¨Ï†Ñ ÏöîÏ≤≠ÏÇ¨Ìï≠ÏùÑ Ïã§Ï†úÎ°ú Ï†ÅÏö©
   */
  private async applyDefaultRequest(
    request: any,
    employee: Employee,
    shiftTemplates: ShiftTemplate[],
    date: string,
    dailyAssignments: GeneratedAssignment[]
  ): Promise<boolean> {
    switch (request.request_type) {
      case 'fixed_shift':
        return this.applyFixedShiftRequest(request, employee, shiftTemplates, date, dailyAssignments)
      
      case 'leave':
      case 'preferred_off':
        return this.applyLeaveRequest(request, employee, shiftTemplates, date, dailyAssignments)
      
      case 'constraint':
        // Ï†úÏïΩÏÇ¨Ìï≠ÏùÄ Î∞∞Ï†ïÏóêÏÑú Ï†úÏô∏ÌïòÎäî Î∞©ÏãùÏúºÎ°ú Ï≤òÎ¶¨Îê®
        console.log(`‚ÑπÔ∏è Constraint applied for ${employee.name}: ${request.description}`)
        return true
      
      default:
        console.log(`‚ö†Ô∏è Unknown request type: ${request.request_type}`)
        return false
    }
  }

  /**
   * Í≥†Ï†ï Í∑ºÎ¨¥ ÏöîÏ≤≠ Ï†ÅÏö©
   */
  private applyFixedShiftRequest(
    request: any,
    employee: Employee,
    shiftTemplates: ShiftTemplate[],
    date: string,
    dailyAssignments: GeneratedAssignment[]
  ): boolean {
    const targetShift = shiftTemplates.find(template => template.type === request.shift_type)
    
    if (!targetShift) {
      console.log(`‚ùå Shift template not found: ${request.shift_type}`)
      return false
    }

    // Ïù¥ÎØ∏ Ìï¥Îãπ ÏãúÌîÑÌä∏Ïóê Î∞∞Ï†ïÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    const existingAssignment = dailyAssignments.find(
      assignment => assignment.employee_id === employee.id
    )

    if (existingAssignment) {
      console.log(`‚ö†Ô∏è Employee ${employee.name} already has assignment`)
      return false
    }

    // Í≥†Ï†ï Í∑ºÎ¨¥ Î∞∞Ï†ï
    dailyAssignments.push({
      employee_id: employee.id,
      shift_template_id: targetShift.id,
      date: date,
      start_time: targetShift.start_time,
      end_time: targetShift.end_time,
      is_overtime: false,
      confidence_score: 1.0 // ÏÇ¨Ï†Ñ ÏöîÏ≤≠Ïù¥ÎØÄÎ°ú ÏµúÍ≥† Ïã†Î¢∞ÎèÑ
    })

    console.log(`üéØ Fixed shift assigned: ${employee.name} -> ${request.shift_type} on ${date}`)
    return true
  }

  /**
   * Ìú¥Í∞Ä/Ìú¥Î¨¥ ÏöîÏ≤≠ Ï†ÅÏö©
   */
  private applyLeaveRequest(
    request: any,
    employee: Employee,
    shiftTemplates: ShiftTemplate[],
    date: string,
    dailyAssignments: GeneratedAssignment[]
  ): boolean {
    const offTemplate = shiftTemplates.find(template => template.type === 'off')
    
    if (offTemplate) {
      dailyAssignments.push({
        employee_id: employee.id,
        shift_template_id: offTemplate.id,
        date: date,
        start_time: offTemplate.start_time,
        end_time: offTemplate.end_time,
        is_overtime: false,
        confidence_score: 1.0
      })
    }

    console.log(`üèñÔ∏è Leave applied: ${employee.name} is off on ${date}`)
    return true
  }

  /**
   * Save generated assignments to database
   */
  async saveAssignments(assignments: GeneratedAssignment[]): Promise<void> {
    const { error } = await this.supabase
      .from('schedule_assignments')
      .insert(
        assignments.map(assignment => ({
          employee_id: assignment.employee_id,
          shift_template_id: assignment.shift_template_id,
          date: assignment.date,
          start_time: assignment.start_time,
          end_time: assignment.end_time,
          is_overtime: assignment.is_overtime,
          status: 'scheduled',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }))
      )

    if (error) {
      throw new Error(`Failed to save assignments: ${error.message}`)
    }
  }

  /**
   * Fetch active mentorship relationships
   */
  private async getActiveMentorships(
    tenantId: string, 
    startDate: string, 
    endDate: string
  ): Promise<MentorshipRelationship[]> {
    const { data: mentorships, error } = await this.supabase
      .from('mentorship_relationships')
      .select('*')
      .eq('tenant_id', tenantId)
      .eq('status', 'active')
      .or(`start_date.lte.${endDate},end_date.gte.${startDate},end_date.is.null`)

    if (error) {
      console.error('Error fetching mentorships:', error)
      return []
    }

    // Cache for use in scoring
    this.cachedMentorships = mentorships || []
    return this.cachedMentorships
  }

  /**
   * Fetch mentoring requirements for tenant
   */
  private async getMentoringRequirements(tenantId: string): Promise<MentoringRequirements | null> {
    const { data: requirements, error } = await this.supabase
      .from('mentoring_requirements')
      .select('*')
      .eq('tenant_id', tenantId)
      .single()

    if (error) {
      console.log('No mentoring requirements found, using defaults')
      return null
    }

    // Cache for use in scoring
    this.cachedMentoringRequirements = requirements
    return requirements
  }

  /**
   * Log mentorship pairing results
   */
  private async logMentorshipPairings(
    assignments: GeneratedAssignment[],
    mentorships: MentorshipRelationship[],
    date: string
  ): Promise<void> {
    const pairings: any[] = []

    for (const mentorship of mentorships) {
      const mentorAssignment = assignments.find(a => a.employee_id === mentorship.mentor_id && a.date === date)
      const menteeAssignment = assignments.find(a => a.employee_id === mentorship.mentee_id && a.date === date)

      if (mentorAssignment && menteeAssignment) {
        const isPaired = mentorAssignment.shift_template_id === menteeAssignment.shift_template_id
        
        pairings.push({
          relationship_id: mentorship.id,
          schedule_date: date,
          shift_type: isPaired ? 
            (await this.getShiftType(mentorAssignment.shift_template_id)) : 
            'different',
          is_paired: isPaired,
          pairing_score: isPaired ? 100 : 0
        })
      }
    }

    if (pairings.length > 0) {
      const { error } = await this.supabase
        .from('mentorship_schedule_pairings')
        .upsert(pairings, { onConflict: 'relationship_id,schedule_date' })

      if (error) {
        console.error('Error logging mentorship pairings:', error)
      }
    }
  }

  /**
   * Get shift type from template ID
   */
  private async getShiftType(shiftTemplateId: string): Promise<string> {
    const { data } = await this.supabase
      .from('shift_templates')
      .select('type')
      .eq('id', shiftTemplateId)
      .single()

    return data?.type || 'unknown'
  }
}